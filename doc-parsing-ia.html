<!DOCTYPE html>
<html lang="en">
	<head>    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Parsing</title>
	<meta name="description" content="Parsing files in <span class='STxT'>STxT</span> format">
	<meta name="author" content="Joan Costa Mombiela">

	<style>@import url('https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400;1,700&display=swap');</style>
    <link rel="stylesheet" href="/css/site.css?v=20241210">
		
			<link rel="alternate" hreflang="es" href="https://stxt.dev/es/doc-parsing-ia" />
					
		
	<link rel="alternate" hreflang="x-default" href="https://stxt.dev/doc-parsing-ia" />
</head>
	
	<body>
		<header id="main_header">
    <div class="title">
		<a href="/">
		                  			<span class='STxT'>STxT</span>: Semantic TexT
			    </a>
	</div>
	<div class="subtitle"><a href="index">One Language, Infinite Possibilities</a></div>
	<ul>
		<li><a href="contribute" title="Cooperate" rel="nofollow">Cooperate</a></li>
		<li><b> | </b></li>
							<li><a href="./es/doc-parsing-ia" title="Español"><i>Español</i></a></li>
			<li><b>English</b></li>
			</ul>
</header>
		<div class="top-bar">
	<ul>
		<li><a href="/" title="Introduction">Introduction</a></li>
		<li><a href="tutorial" title="Tutorial">Tutorial</a></li>
		<li><a href="examples" title="Examples">Examples</a></li>
		<li><a href="parsers" title="Parsers">Parsers</a></li>
		<li class="link_src"><a href="doc-parsing-ia.stxt" target="doc-parsing-ia" title="Source <span class='STxT'>STxT</span>">Source Code</a></li>
	</ul>
</div>
	
		<div id="main_content" class="clearfix">
  <article>
		<div class="column row book_nav clearfix">
		
		           	<a style="float:left;"	href="ebnf" title="Previous">&#x25C4; Previous</a>
				           	<a style="float:right;" href="parsers" title="Next">Next &#x25BA;</a>
			</div>

	
										<h1><a id="index_0"></a><span class='STxT'>STxT</span> Parsing</h1>
					<h2><a id="index_1"></a>Generic Process</h2>
					<h3><a id="index_2"></a>Line-by-line Parsing</h3>
					<p>The parsing process can be done line by line, using a stack to maintain the hierarchy.
The general algorithm is:</p>

				<pre>ALGORITHM: parse(content)
	stack = empty stack
	currentRoot = null
	currentLevel = 0
	document = empty list
	
	for each line in content:
		result = processLine(line, stack, currentLevel, currentRoot)
		currentLevel = result.level
		currentRoot = result.rootNode
	
	if currentRoot is not null:
		finalizeNode(currentRoot)
		document.add(currentRoot)
	
	return document</pre>
				<p>The key is to maintain a <strong>stack of nodes</strong> that represents the current hierarchy.
Each element of the stack is the parent node of the next level. In this way, the processing
of each line is independent and very efficient.</p>

				<h3><a id="index_3"></a>Line Processing: Step by Step</h3>
					<p>Processing a line consists of these steps:</p>

				<pre>STEP 1: NORMALIZATION AND LEVEL EXTRACTION
	- Remove UTF-8 BOM if present
	- If it's a comment (#...): ignore the line
	- If it's empty: depends on context (see multiline)
	- Detect compact format (2:name:value) &larr; convert to indentation
	- Count spaces/tabs: each tab = 1 level, every 4 spaces = 1 level
	- If there are 1-3 loose spaces: ERROR

Result: lineIndent = { level, textWithoutIndent }</pre>
				<pre>STEP 2: MULTILINE NODE HANDLING
	
	if (previous_node_is_multiline) AND (level &gt;= stack_level):
		// The line is a continuation of the previous multiline node
		add_line_to_multiline_node(previous_node, text)
		return
	
	if (previous_node_is_multiline) AND (level &lt; stack_level):
		// Multiline node ended, process normally
		finalizeNode(previous_node)
	
	if line is empty AND (there is an active multiline node):
		// Empty line inside multiline = line break
		add_line_to_multiline_node(previous_node, &quot;&quot;)
		return</pre>
				<pre>STEP 3: LEVEL VALIDATION
	
	if level &gt; (current_level + 1):
		// Invalid level jump, e.g.: level 0 &rarr; level 2
		throw ERROR &quot;Incorrect level jump&quot;
	
	// Levels must be consecutive</pre>
				<pre>STEP 4: CREATE NODE FROM LINE
	
	Parse the line with regex/search:
		if starts with ':' &rarr; it's multiline
			name = extract between first and second ':'
			value = text after the second ':'
		else:
			find first ':'
			name = text before ':'
			value = text after ':'
		
		if name is empty: ERROR
		convert name to lowercase (case-insensitive)
	
	Result: node = Node(name, value, isMultiline, line)</pre>
				<pre>STEP 5: STACK HIERARCHY MANAGEMENT
	
	if level == 0:
		// Root node
		if currentRoot is not null:
			finalizeNode(currentRoot)
			document.add(currentRoot)
		currentRoot = node
		stack.clear()
		stack.push(currentRoot)
	
	else:
		// Child node
		while stack.size() &gt; level:
			finished_node = stack.pop()
			finalizeNode(finished_node)
		
		// Now stack.size() == level
		parent = stack.top()
		parent.addChild(node)
		stack.push(node)</pre>
				<p>Important: When a node disappears from the stack (because we find a lower level),
it is time to finalize and validate it.</p>

				<h3><a id="index_4"></a>Execution Trace Example</h3>
					<p>Document:</p>

				<pre>Email:
	From: John
	To: Mary
	:Body:
		Hello
		World
	Priority: High
Phone:
	Number: 123</pre>
				<p>Step-by-step trace:</p>

				<pre>LINE 1: &quot;Email:&quot;
	Level: 0, Name: &quot;email&quot;, Value: null, Multiline: false
	Stack: [Email]
	currentRoot = Email

LINE 2: &quot;    From: John&quot;
	Level: 1, Name: &quot;from&quot;, Value: &quot;John&quot;, Multiline: false
	Parent: Email
	Stack: [Email, From]

LINE 3: &quot;    To: Mary&quot;
	Level: 1, Name: &quot;to&quot;, Value: &quot;Mary&quot;, Multiline: false
	Stack.pop() until size 1 (finalize From)
	Parent: Email
	Stack: [Email, To]

LINE 4: &quot;    :Body:&quot;
	Level: 1, Name: &quot;body&quot;, Value: null, Multiline: true
	Stack: [Email, Body]
	Mark Body as multiline mode

LINE 5: &quot;        Hello&quot;
	Level: 2, but Body is multiline and 2 &gt;= stack.size(1)
	APPEND TO BODY! Do not create new node
	Body.lines = [&quot;Hello&quot;]

LINE 6: &quot;        World&quot;
	Level: 2, but Body is multiline and 2 &gt;= stack.size(1)
	APPEND TO BODY! Do not create new node
	Body.lines = [&quot;Hello&quot;, &quot;World&quot;]

LINE 7: &quot;    Priority: High&quot;
	Level: 1, Body is multiline but 1 &lt; stack.size(1)
	Finalize Body (convert lines to text)
	Stack.pop() until size 1
	Parent: Email
	Stack: [Email, Priority]

LINE 8: (empty)
	Ignore

LINE 9: &quot;Phone:&quot;
	Level: 0
	Finalize Email
	document.add(Email)
	currentRoot = Phone
	Stack: [Phone]</pre>
				<p>Final result: document contains [Email, Phone] with their hierarchical structure.</p>

				<h3><a id="index_5"></a>Optimized Pseudocode for LLM</h3>
					<p>With this understanding, the pseudocode to implement in any language is:</p>

				<pre>class ParsingState:
	stack = []
	currentRoot = None
	currentLevel = 0
	document = []

def parse(content):
	state = ParsingState()
	lines = content.split('\n')
	
	for lineNumber, rawLine in enumerate(lines):
		lineData = normalizeLine(rawLine, state.stack)
		if lineData is None:
			continue  // Comment or empty line
		
		processLine(lineData, state)
	
	finalizeBatch(state)
	return state.document

def normalizeLine(line, stack):
	// Returns: {level, text, isComment, isMultiline}
	if line.startswith(&quot;#&quot;):
		return None  // Comment
	
	level = countIndentation(line)
	textWithoutIndent = line[indentLength:]
	
	if textWithoutIndent.startswith(&quot;:&quot;):
		isMultiline = True
	
	return {level, textWithoutIndent, isMultiline}

def processLine(lineData, state):
	// Main logic from step 1 to 5 described above
	
	lastNode = state.stack[-1] if state.stack else None
	
	// STEP 2: Multiline
	if lastNode.isMultiline and lineData.level &gt;= len(state.stack):
		lastNode.addLine(lineData.text)
		return
	
	// STEP 3: Validation
	if lineData.level &gt; state.currentLevel + 1:
		throwError(&quot;Level jump&quot;)
	
	// STEP 4: Create node
	node = createNode(lineData.text, lineData.level)
	
	// STEP 5: Stack
	if lineData.level == 0:
		state.document.append(state.currentRoot)
		state.currentRoot = node
		state.stack = [node]
	else:
		while len(state.stack) &gt; lineData.level:
			state.stack.pop()
		state.stack[-1].addChild(node)
		state.stack.append(node)
	
	state.currentLevel = lineData.level</pre>
				<h3><a id="index_6"></a>Node Validations with Namespace</h3>
					<p>Validations occur at two key moments during parsing:</p>

				<p><strong>1. When creating a new node (namespace validation):</strong></p>
<p>When a node is created, the parser tries to deduce its namespace from:</p>
<ul>
<li>The explicit namespace in the node: <code>Email(com.example.docs)</code></li>
<li>The parent's namespace</li>
<li>The repository of available namespaces</li>
</ul>
<p>If it cannot deduce a valid namespace, it throws ERROR.</p>

				<p><strong>2. When finalizing a node (structure and content validation):</strong></p>
<p>This occurs when:</p>
<ul>
<li>A node appears with level &lt;= current level (branch closure)</li>
<li>The end of the file is reached</li>
</ul>
<p>At this moment, it validates:</p>

				<pre>if nodeType == NODE:
	validate that the number of children is correct
		example: Email has {From, To, Body, Priority}
		validated against the namespace

else (if STRING, NUMBER, TEXT, etc):
	validate content according to type
		example: NUMBER must match ^(\-|\+)?\d+\.\d+(e(\-|\+)?\d+)?$

if TEXT (multiline):
	validate that it has no children (only textual content)

if BOOLEAN:
	validate that value is &quot;true&quot; or &quot;false&quot;</pre>
				<p><strong>Complete validation example:</strong></p>

				<pre>Invalid input:
	Email (com.example.docs):
		From: John
		Priority: alto  &larr; ERROR: &quot;alto&quot; is not boolean

Stack during processing:
	LINE &quot;From: John&quot;: ok, level 1
	LINE &quot;Priority: alto&quot;: create node
		- Deduce type of Priority in namespace
		- Type = BOOLEAN
		- Value = &quot;alto&quot;
		- Validate with BOOLEAN regex
		- FAILS: &quot;alto&quot; != &quot;true&quot; | &quot;false&quot;
		- Throw ParseException</pre>
				<h2><a id="index_7"></a>Language Nodes</h2>
					<p>In the language description we said that data types have no limitation
nor are they tied to a language, so validations should only be checked
using regular expressions or methods that ensure this fact.</p>
<p>We have the following node types:</p>
<ul>
<li>NODE</li>
<li>TEXT</li>
<li>URL</li>
<li>NATURAL</li>
<li>INTEGER</li>
<li>RATIONAL</li>
<li>NUMBER</li>
<li>BINARY</li>
<li>HEXADECIMAL</li>
<li>BASE64</li>
<li>BOOLEAN</li>
</ul>
<p>The regular expressions we could use to validate nodes are:</p>

				<pre>BINARY       = ^(0|1|\s)+$
BOOLEAN      = ^0|1$
HEXADECIMAL  = ^([a-f0-9]|\s)+$
INTEGER      = ^(\-|\+)?\d+$
NATURAL      = ^\d+$
NUMBER       = ^(\-|\+)?\d+\.\d+(e(\-|\+)?\d+)?$
RATIONAL     = ^(\-|\+)?\d+\/\d+$</pre>
				<h2><a id="index_8"></a>Namespaces</h2>
					<h3><a id="index_9"></a>Storage</h3>
					<p>Namespaces must be obtained independently. One strategy is to have a namespace repository
on disk, and always fetch them from there.</p>

				<h2><a id="index_10"></a>Details to Consider</h2>
					<p>There are some details to keep in mind during parsing:</p>
<ul>
<li>Case-insensitive: All nodes are considered CASE-INSENSITIVE,
so the appropriate transformations must be made during the parsing process.</li>
<li>Base64: With BASE64 text, line breaks must be allowed,
and a standard parse of the resulting content should be performed.</li>
<li>For reading lines, both UNIX and DOS formats must be considered.
Therefore, we will allow both line feed and line feed + carriage return.
This is to allow quick file edits from any environment,
although the most appropriate would always be to use UNIX standard (line feed only).</li>
</ul>

	
		<div class="column row book_nav clearfix">
		
		           	<a style="float:left;"	href="ebnf" title="Previous">&#x25C4; Previous</a>
				           	<a style="float:right;" href="parsers" title="Next">Next &#x25BA;</a>
			</div>
  </article>
  
  <aside id="index_content">
			<div class="d-none d-md-block" style="margin-bottom:3rem;">
											<h2><a id="index_11"></a>Introduction</h2>
							<div class="link">
		<a href="index" ><span class='STxT'>STxT</span> in 1 Minute</a>
	</div>
						<div class="link">
		<a href="tutorial" ><span class='STxT'>STxT</span> Tutorial</a>
	</div>
						<h2><a id="index_12"></a>The Language</h2>
							<div class="link">
		<a href="raw-docs" >Documents without namespace</a>
	</div>
						<div class="link">
		<a href="ns-docs" >Documents with namespace</a>
	</div>
						<div class="link">
		<a href="compact" >Compaction</a>
	</div>
						<div class="link">
		<a href="examples" >Examples</a>
	</div>
						<h2><a id="index_13"></a>Technical Resources</h2>
							<div class="link">
		<a href="ebnf" >EBNF</a>
	</div>
						<div class="link">
		<a href="doc-parsing" >Document Parsing</a>
	</div>
						<div class="link">
		<a href="parsers" >Available Parsers</a>
	</div>
				</div>
	  </aside>
</div>
		<footer><p>&copy; 2025 - This work is licensed under a <a rel="license" style="text-decoration:underline" href="https://raw.githubusercontent.com/mombiela/semantic-web-builder/master/LICENSE">MIT License</a>.</p></footer>
	</body>
</html>
