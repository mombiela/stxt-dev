<!DOCTYPE html>
<html lang="es">
	<head>    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parseo de Documentos</title>
	<meta name="description" content="Parseo de ficheros en formato <span class='STxT'>STXT</span>">
	<meta name="author" content="Joan Costa Mombiela">

	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Russo+One&display=swap" rel="stylesheet">

	<style>@import url('https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400;1,700&display=swap');</style>
    <link rel="stylesheet" href="/css/site.css?v=20241210">
    
    
    
		
			
			<link rel="alternate" hreflang="en" href="https://stxt.dev/doc-parsing-ia" />
				
	<link rel="alternate" hreflang="x-default" href="https://stxt.dev/doc-parsing-ia" />
</head>
	
	<body>
		<header id="main_header">
    <div class="title">
		<a href="/es">
		                  			<span class='STxT'>STXT</span>: Semantic Text
			    </a>
	</div>
	<div class="subtitle"><a href="index">Un Lenguaje, Infinitas Posibilidades</a></div>
	<ul>
		<li><a href="contribute" title="Contribuir" rel="nofollow">Contribuir</a></li>
		<li><b> | </b></li>
					<li><b>Español</b></li>
			<li><a href="../doc-parsing-ia" title="Español"><i>English</i></a></li>
					</ul>
</header>
		<div class="top-bar">
	<ul>
		<li><a href="/es" title="Introducción">Introducción</a></li>
		<li><a href="tutorial" title="Tutorial">Tutorial</a></li>
		<li><a href="examples" title="Ejemplos">Ejemplos</a></li>
		<li><a href="parsers" title="Parsers">Parsers</a></li>
		<li class="link_src"><a href="doc-parsing-ia.stxt" target="doc-parsing-ia" title="File doc-parsing-ia.stxt"><span class='STxT'>STXT</span></a></li>
	</ul>
</div>
	
		<div id="main_content" class="clearfix">
  <article>
		<div class="column row book_nav clearfix">
		
		           	<a style="float:left;"	href="ebnf" title="Anterior">&#x25C4; Anterior</a>
				           	<a style="float:right;" href="parsers" title="Siguiente">Siguiente &#x25BA;</a>
			</div>

	
										<h1><a id="index_0"></a>Parseo de <span class='STxT'>STXT</span></h1>
					<h2><a id="index_1"></a>Proceso genérico</h2>
					<h3><a id="index_2"></a>Parseo por líneas</h3>
					<p>El proceso de parseo puede hacerse línea a línea, utilizando una pila (stack) para mantener la jerarquía.
El algoritmo general es:</p>

				<pre>ALGORITMO: parse(contenido)
	stack = pila vac&iacute;a
	currentRoot = null
	currentLevel = 0
	documento = lista vac&iacute;a
	
	para cada l&iacute;nea del contenido:
		resultado = procesarL&iacute;nea(l&iacute;nea, stack, currentLevel, currentRoot)
		currentLevel = resultado.nivel
		currentRoot = resultado.nodoRa&iacute;z
	
	si currentRoot no es nulo:
		finalizarNodo(currentRoot)
		documento.a&ntilde;adir(currentRoot)
	
	devolver documento</pre>
				<p>La clave está en mantener una <strong>pila (stack) de nodos</strong> que representa la jerarquía actual.
Cada elemento de la pila es el nodo padre del siguiente nivel. De esta forma, el procesado
de cada línea es independiente y muy eficiente.</p>

				<h3><a id="index_3"></a>Procesado de línea: Paso a paso</h3>
					<p>El procesado de una línea consta de estos pasos:</p>

				<pre>PASO 1: NORMALIZACI&Oacute;N Y EXTRACCI&Oacute;N DE NIVEL
	- Eliminar BOM UTF-8 si existe
	- Si es comentario (#...): ignorar la l&iacute;nea
	- Si est&aacute; vac&iacute;a: depende del contexto (ver multil&iacute;nea)
	- Detectar formato compacto (2:nombre:valor) &larr; convertir a indentaci&oacute;n
	- Contar espacios/tabuladores: cada tab = 1 nivel, cada 4 espacios = 1 nivel
	- Si hay 1-3 espacios sueltos: ERROR

Resultado: lineIndent = { nivel, textoSinIndent }</pre>
				<pre>PASO 2: MANEJO DE NODOS MULTIL&Iacute;NEA
	
	si (nodo_anterior_es_multil&iacute;nea) Y (nivel &gt;= nivel_stack):
		// La l&iacute;nea es continuaci&oacute;n del nodo multil&iacute;nea anterior
		a&ntilde;adir_l&iacute;nea_a_nodo_multil&iacute;nea(nodo_anterior, texto)
		retornar
	
	si (nodo_anterior_es_multil&iacute;nea) Y (nivel &lt; nivel_stack):
		// Termin&oacute; el nodo multil&iacute;nea, procesar normalmente
		finalizarNodo(nodo_anterior)
	
	si l&iacute;nea est&aacute; vac&iacute;a Y (hay nodo multil&iacute;nea activo):
		// L&iacute;nea vac&iacute;a dentro de multil&iacute;nea = salto de l&iacute;nea
		a&ntilde;adir_l&iacute;nea_a_nodo_multil&iacute;nea(nodo_anterior, &quot;&quot;)
		retornar</pre>
				<pre>PASO 3: VALIDACI&Oacute;N DE NIVELES
	
	si nivel &gt; (nivel_actual + 1):
		// Salto de nivel inv&aacute;lido, ej: nivel 0 &rarr; nivel 2
		lanzar ERROR &quot;Salto de nivel incorrecto&quot;
	
	// Los niveles deben ser consecutivos</pre>
				<pre>PASO 4: CREAR NODO DESDE LA L&Iacute;NEA
	
	Parsear la l&iacute;nea con regex/b&uacute;squeda:
		si comienza con ':' &rarr; es multil&iacute;nea
			nombre = extraer entre primero y segundo ':'
			valor = texto despu&eacute;s del segundo ':'
		sino:
			buscar primer ':'
			nombre = texto antes de ':'
			valor = texto despu&eacute;s de ':'
		
		si nombre est&aacute; vac&iacute;o: ERROR
		convertir nombre a min&uacute;sculas (case-insensitive)
	
	Resultado: node = Node(nombre, valor, esMultil&iacute;nea, l&iacute;nea)</pre>
				<pre>PASO 5: GESTI&Oacute;N DE LA JERARQU&Iacute;A CON STACK
	
	si nivel == 0:
		// Nodo ra&iacute;z
		si currentRoot no es nulo:
			finalizarNodo(currentRoot)
			documento.a&ntilde;adir(currentRoot)
		currentRoot = node
		stack.limpiar()
		stack.insertar(currentRoot)
	
	sino:
		// Nodo hijo
		mientras stack.tama&ntilde;o() &gt; nivel:
			nodo_finalizado = stack.extraer()
			finalizarNodo(nodo_finalizado)
		
		// Ahora stack.tama&ntilde;o() == nivel
		padre = stack.cima()
		padre.a&ntilde;adirHijo(node)
		stack.insertar(node)</pre>
				<p>Importante: Cuando un nodo desaparece de la pila (porque encontramos un nivel inferior),
es momento de finalizarlo y validarlo.</p>

				<h3><a id="index_4"></a>Ejemplo de traza de ejecución</h3>
					<p>Documento:</p>

				<pre>Email:
	From: John
	To: Mary
	:Body:
		Hello
		World
	Priority: High
Phone:
	Number: 123</pre>
				<p>Traza paso a paso:</p>

				<pre>L&Iacute;NEA 1: &quot;Email:&quot;
	Nivel: 0, Nombre: &quot;email&quot;, Valor: null, Multil&iacute;nea: false
	Stack: [Email]
	currentRoot = Email

L&Iacute;NEA 2: &quot;    From: John&quot;
	Nivel: 1, Nombre: &quot;from&quot;, Valor: &quot;John&quot;, Multil&iacute;nea: false
	Padre: Email
	Stack: [Email, From]

L&Iacute;NEA 3: &quot;    To: Mary&quot;
	Nivel: 1, Nombre: &quot;to&quot;, Valor: &quot;Mary&quot;, Multil&iacute;nea: false
	Stack.pop() hasta tama&ntilde;o 1 (finalizar From)
	Padre: Email
	Stack: [Email, To]

L&Iacute;NEA 4: &quot;    :Body:&quot;
	Nivel: 1, Nombre: &quot;body&quot;, Valor: null, Multil&iacute;nea: true
	Stack: [Email, Body]
	Marca Body como modo multil&iacute;nea

L&Iacute;NEA 5: &quot;        Hello&quot;
	Nivel: 2, pero Body es multil&iacute;nea y 2 &gt;= stack.size(1)
	&iexcl;APPEND A BODY! No crear nuevo nodo
	Body.lines = [&quot;Hello&quot;]

L&Iacute;NEA 6: &quot;        World&quot;
	Nivel: 2, pero Body es multil&iacute;nea y 2 &gt;= stack.size(1)
	&iexcl;APPEND A BODY! No crear nuevo nodo
	Body.lines = [&quot;Hello&quot;, &quot;World&quot;]

L&Iacute;NEA 7: &quot;    Priority: High&quot;
	Nivel: 1, Body es multil&iacute;nea pero 1 &lt; stack.size(1)
	Finalizar Body (convertir lines a texto)
	Stack.pop() hasta tama&ntilde;o 1
	Padre: Email
	Stack: [Email, Priority]

L&Iacute;NEA 8: (vac&iacute;a)
	Ignorar

L&Iacute;NEA 9: &quot;Phone:&quot;
	Nivel: 0
	Finalizar Email
	documento.add(Email)
	currentRoot = Phone
	Stack: [Phone]</pre>
				<p>Resultado final: documento contiene [Email, Phone] con su estructura jerárquica.</p>

				<h3><a id="index_5"></a>Pseudocódigo optimizado para LLM</h3>
					<p>Con esta comprensión, el pseudocódigo para implementar en cualquier lenguaje es:</p>

				<pre>class ParsingState:
	stack = []
	currentRoot = None
	currentLevel = 0
	document = []

def parse(content):
	state = ParsingState()
	lines = content.split('\n')
	
	for lineNumber, rawLine in enumerate(lines):
		lineData = normalizeLine(rawLine, state.stack)
		if lineData is None:
			continue  // Comentario o l&iacute;nea vac&iacute;a
		
		processLine(lineData, state)
	
	finalizeBatch(state)
	return state.document

def normalizeLine(line, stack):
	// Retorna: {nivel, texto, esComentario, esMultil&iacute;nea}
	if line.startswith(&quot;#&quot;):
		return None  // Comentario
	
	nivel = countIndentation(line)
	textoSinIndent = line[indentLength:]
	
	if textoSinIndent.startswith(&quot;:&quot;):
		esMultil&iacute;nea = True
	
	return {nivel, textoSinIndent, esMultil&iacute;nea}

def processLine(lineData, state):
	// L&oacute;gica principal del paso 1 al 5 descrito arriba
	
	ultimoNodo = state.stack[-1] if state.stack else None
	
	// PASO 2: Multil&iacute;nea
	if ultimoNodo.esMultil&iacute;nea and lineData.nivel &gt;= len(state.stack):
		ultimoNodo.a&ntilde;adirL&iacute;nea(lineData.texto)
		return
	
	// PASO 3: Validaci&oacute;n
	if lineData.nivel &gt; state.currentLevel + 1:
		lanzarError(&quot;Salto de nivel&quot;)
	
	// PASO 4: Crear nodo
	node = crearNodo(lineData.texto, lineData.nivel)
	
	// PASO 5: Stack
	if lineData.nivel == 0:
		state.document.append(state.currentRoot)
		state.currentRoot = node
		state.stack = [node]
	else:
		while len(state.stack) &gt; lineData.nivel:
			state.stack.pop()
		state.stack[-1].a&ntilde;adirHijo(node)
		state.stack.append(node)
	
	state.currentLevel = lineData.nivel</pre>
				<h3><a id="index_6"></a>Validaciones nodos con namespace</h3>
					<p>Las validaciones ocurren en dos momentos clave durante el parseo:</p>

				<p><strong>1. Al crear un nodo nuevo (validación de namespace):</strong></p>
<p>Cuando se crea un nodo, el parser intenta deducir su namespace a partir de:</p>
<ul>
<li>El namespace explícito en el nodo: <code>Email(com.example.docs)</code></li>
<li>El namespace del padre</li>
<li>El repositorio de namespaces disponibles</li>
</ul>
<p>Si no puede deducir un namespace válido, lanza ERROR.</p>

				<p><strong>2. Al finalizar un nodo (validación de estructura y contenido):</strong></p>
<p>Esto ocurre cuando:</p>
<ul>
<li>Aparece un nodo con nivel &lt;= nivel actual (cierre de rama)</li>
<li>Se alcanza el final del fichero</li>
</ul>
<p>En este momento se valida:</p>

				<pre>si tipoNodo == NODE:
	validar que n&uacute;mero de hijos sea correcto
		ejemplo: Email tiene {From, To, Body, Priority}
		se valida contra el namespace

sino (si es STRING, NUMBER, TEXT, etc):
	validar contenido seg&uacute;n tipo
		ejemplo: NUMBER debe cumplir ^(\-|\+)?\d+\.\d+(e(\-|\+)?\d+)?$

si es TEXT (multil&iacute;nea):
	validar que no tenga hijos (solo contenido textual)

si es BOOLEAN:
	validar que valor sea &quot;true&quot; o &quot;false&quot;</pre>
				<p><strong>Ejemplo completo de validación:</strong></p>

				<pre>Entrada inv&aacute;lida:
	Email (com.example.docs):
		From: John
		Priority: alto  &larr; ERROR: &quot;alto&quot; no es booleano

Stack durante procesado:
	L&Iacute;NEA &quot;From: John&quot;: ok, nivel 1
	L&Iacute;NEA &quot;Priority: alto&quot;: crear nodo
		- Deducir tipo de Priority en namespace
		- Tipo = BOOLEAN
		- Valor = &quot;alto&quot;
		- Validar con regex BOOLEAN
		- FALLA: &quot;alto&quot; != &quot;true&quot; | &quot;false&quot;
		- Lanzar ParseException</pre>
				<h2><a id="index_7"></a>Los nodos del lenguaje</h2>
					<p>En la descripción del lenguaje habíamos dicho que los tipos de datos no tienen limitación
ni están ligados a un lenguaje, por lo que las validaciones sólo deberían ser comprobadas
mediante expresiones regulares o métodos que aseguren este hecho.</p>
<p>Tenemos los siguientes tipos de nodos:</p>
<ul>
<li>NODE</li>
<li>TEXT</li>
<li>URL</li>
<li>NATURAL</li>
<li>INTEGER</li>
<li>RATIONAL</li>
<li>NUMBER</li>
<li>BINARY</li>
<li>HEXADECIMAL</li>
<li>BASE64</li>
<li>BOOLEAN</li>
</ul>
<p>Las expresiones regulares que podríamos usar para validar nodos son:</p>

				<pre>BINARY       = ^(0|1|\s)+$
BOOLEAN      = ^0|1$
HEXADECIMAL  = ^([a-f0-9]|\s)+$
INTEGER      = ^(\-|\+)?\d+$
NATURAL      = ^\d+$
NUMBER       = ^(\-|\+)?\d+\.\d+(e(\-|\+)?\d+)?$
RATIONAL     = ^(\-|\+)?\d+\/\d+$</pre>
				<h2><a id="index_8"></a>Namespaces</h2>
					<h3><a id="index_9"></a>Almacenaje</h3>
					<p>Los namespaces se deben obtener de forma independiente. Una estrategia es tener un repositorio de namespaces
en disco, e ir a buscarlos siempre allí.</p>

				<h2><a id="index_10"></a>Detalles a tener en cuenta</h2>
					<p>Hay algunos detalles que hay que tener en cuenta en el parseo:</p>
<ul>
<li>Case-insensitive: Todos los nodos son considerados CASE-INSENSITIVE,
por lo que hay que hacer las transformaciones adecuadas en el proceso de parseo.</li>
<li>Base64: Con el texto BASE64 hay que permitir saltos de línea,
y hacer un parseo estándar del contenido así obtenido.</li>
<li>Para lectura de líneas hay que tener en cuenta tanto formato UNIX como DOS.
Por ello permitiremos tanto el salto de línea, como salto de línea + retorno de carro.
Esto lo hacemos para permitir ediciones rápidas de ficheros desde cualquier entorno,
aunque lo más adecuado sería siempre usar estándar UNIX (sólo carácter de salto de línea).</li>
</ul>

	
		<div class="column row book_nav clearfix">
		
		           	<a style="float:left;"	href="ebnf" title="Anterior">&#x25C4; Anterior</a>
				           	<a style="float:right;" href="parsers" title="Siguiente">Siguiente &#x25BA;</a>
			</div>
  </article>
  
  <aside id="index_content">
			<div class="d-none d-md-block" style="margin-bottom:3rem;">
											<h2><a id="index_11"></a>Introducción</h2>
							<div class="link">
		<a href="index" ><span class='STxT'>STXT</span> en 1 Minuto</a>
	</div>
						<div class="link">
		<a href="tutorial" ><span class='STxT'>STXT</span> Tutorial</a>
	</div>
						<h2><a id="index_12"></a>El lenguaje</h2>
							<div class="link">
		<a href="raw-docs" >Documentos sin namespace</a>
	</div>
						<div class="link">
		<a href="ns-docs" >Documentos con namespace</a>
	</div>
						<div class="link">
		<a href="compact" >Compactación</a>
	</div>
						<div class="link">
		<a href="examples" >Ejemplos</a>
	</div>
						<h2><a id="index_13"></a>Recursos técnicos</h2>
							<div class="link">
		<a href="ebnf" >EBNF</a>
	</div>
						<div class="link">
		<a href="doc-parsing" >Parseo de documentos</a>
	</div>
						<div class="link">
		<a href="parsers" >Parsers disponibles</a>
	</div>
				</div>
	  </aside>
</div>
		<footer><p>&copy; 2025 - Este obra está bajo una <a style="text-decoration:underline" rel="license" href="https://raw.githubusercontent.com/mombiela/semantic-web-builder/master/LICENSE">Licencia MIT</a>.</p></footer>
	</body>
</html>
