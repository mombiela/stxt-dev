Document (dev.stxt.namespace): Parseo de Documentos
	Navigation:
		Previous: Anterior (ebnf)
		Next: Siguiente (parsers)
		
	Metadata:
		Title: Parseo de @STXT@
		Description: Parseo de ficheros en formato @STXT@
		Author: Joan Costa Mombiela
		last modif: 2025-11-30
	
	header:	Parseo de @STXT@
		
	Subheader:	Proceso genérico
		
	SubSubheader:Parseo por líneas
		
	Content:
		El proceso de parseo puede hacerse línea a línea, utilizando una pila (stack) para mantener la jerarquía.
		El algoritmo general es:
		
	code:
		ALGORITMO: parse(contenido)
			stack = pila vacía
			currentRoot = null
			currentLevel = 0
			documento = lista vacía
			
			para cada línea del contenido:
				resultado = procesarLínea(línea, stack, currentLevel, currentRoot)
				currentLevel = resultado.nivel
				currentRoot = resultado.nodoRaíz
			
			si currentRoot no es nulo:
				finalizarNodo(currentRoot)
				documento.añadir(currentRoot)
			
			devolver documento
		
	Content:
		La clave está en mantener una **pila (stack) de nodos** que representa la jerarquía actual.
		Cada elemento de la pila es el nodo padre del siguiente nivel. De esta forma, el procesado
		de cada línea es independiente y muy eficiente.
		
	subSubheader:Procesado de línea: Paso a paso
		
	Content:
		El procesado de una línea consta de estos pasos:
		
	code:
		PASO 1: NORMALIZACIÓN Y EXTRACCIÓN DE NIVEL
			- Eliminar BOM UTF-8 si existe
			- Si es comentario (#...): ignorar la línea
			- Si está vacía: depende del contexto (ver multilínea)
			- Detectar formato compacto (2:nombre:valor) ← convertir a indentación
			- Contar espacios/tabuladores: cada tab = 1 nivel, cada 4 espacios = 1 nivel
			- Si hay 1-3 espacios sueltos: ERROR
		
		Resultado: lineIndent = { nivel, textoSinIndent }
		
	code:
		PASO 2: MANEJO DE NODOS MULTILÍNEA
			
			si (nodo_anterior_es_multilínea) Y (nivel >= nivel_stack):
				// La línea es continuación del nodo multilínea anterior
				añadir_línea_a_nodo_multilínea(nodo_anterior, texto)
				retornar
			
			si (nodo_anterior_es_multilínea) Y (nivel < nivel_stack):
				// Terminó el nodo multilínea, procesar normalmente
				finalizarNodo(nodo_anterior)
			
			si línea está vacía Y (hay nodo multilínea activo):
				// Línea vacía dentro de multilínea = salto de línea
				añadir_línea_a_nodo_multilínea(nodo_anterior, "")
				retornar
		
	code:
		PASO 3: VALIDACIÓN DE NIVELES
			
			si nivel > (nivel_actual + 1):
				// Salto de nivel inválido, ej: nivel 0 → nivel 2
				lanzar ERROR "Salto de nivel incorrecto"
			
			// Los niveles deben ser consecutivos
		
	code:
		PASO 4: CREAR NODO DESDE LA LÍNEA
			
			Parsear la línea con regex/búsqueda:
				si comienza con ':' → es multilínea
					nombre = extraer entre primero y segundo ':'
					valor = texto después del segundo ':'
				sino:
					buscar primer ':'
					nombre = texto antes de ':'
					valor = texto después de ':'
				
				si nombre está vacío: ERROR
				convertir nombre a minúsculas (case-insensitive)
			
			Resultado: node = Node(nombre, valor, esMultilínea, línea)
		
	code:
		PASO 5: GESTIÓN DE LA JERARQUÍA CON STACK
			
			si nivel == 0:
				// Nodo raíz
				si currentRoot no es nulo:
					finalizarNodo(currentRoot)
					documento.añadir(currentRoot)
				currentRoot = node
				stack.limpiar()
				stack.insertar(currentRoot)
			
			sino:
				// Nodo hijo
				mientras stack.tamaño() > nivel:
					nodo_finalizado = stack.extraer()
					finalizarNodo(nodo_finalizado)
				
				// Ahora stack.tamaño() == nivel
				padre = stack.cima()
				padre.añadirHijo(node)
				stack.insertar(node)
		
	Content:
		Importante: Cuando un nodo desaparece de la pila (porque encontramos un nivel inferior),
		es momento de finalizarlo y validarlo.
		
	subSubheader:Ejemplo de traza de ejecución
		
	Content:
		Documento:
		
	code:
		Email:
			From: John
			To: Mary
			:Body:
				Hello
				World
			Priority: High
		Phone:
			Number: 123
	
	Content:
		Traza paso a paso:
		
	code:
		LÍNEA 1: "Email:"
			Nivel: 0, Nombre: "email", Valor: null, Multilínea: false
			Stack: [Email]
			currentRoot = Email
		
		LÍNEA 2: "    From: John"
			Nivel: 1, Nombre: "from", Valor: "John", Multilínea: false
			Padre: Email
			Stack: [Email, From]
		
		LÍNEA 3: "    To: Mary"
			Nivel: 1, Nombre: "to", Valor: "Mary", Multilínea: false
			Stack.pop() hasta tamaño 1 (finalizar From)
			Padre: Email
			Stack: [Email, To]
		
		LÍNEA 4: "    :Body:"
			Nivel: 1, Nombre: "body", Valor: null, Multilínea: true
			Stack: [Email, Body]
			Marca Body como modo multilínea
		
		LÍNEA 5: "        Hello"
			Nivel: 2, pero Body es multilínea y 2 >= stack.size(1)
			¡APPEND A BODY! No crear nuevo nodo
			Body.lines = ["Hello"]
		
		LÍNEA 6: "        World"
			Nivel: 2, pero Body es multilínea y 2 >= stack.size(1)
			¡APPEND A BODY! No crear nuevo nodo
			Body.lines = ["Hello", "World"]
		
		LÍNEA 7: "    Priority: High"
			Nivel: 1, Body es multilínea pero 1 < stack.size(1)
			Finalizar Body (convertir lines a texto)
			Stack.pop() hasta tamaño 1
			Padre: Email
			Stack: [Email, Priority]
		
		LÍNEA 8: (vacía)
			Ignorar
		
		LÍNEA 9: "Phone:"
			Nivel: 0
			Finalizar Email
			documento.add(Email)
			currentRoot = Phone
			Stack: [Phone]
	
	Content:
		Resultado final: documento contiene [Email, Phone] con su estructura jerárquica.
		
	subSubheader:Pseudocódigo optimizado para LLM
		
	Content:
		Con esta comprensión, el pseudocódigo para implementar en cualquier lenguaje es:
		
	code:
		class ParsingState:
			stack = []
			currentRoot = None
			currentLevel = 0
			document = []
		
		def parse(content):
			state = ParsingState()
			lines = content.split('\n')
			
			for lineNumber, rawLine in enumerate(lines):
				lineData = normalizeLine(rawLine, state.stack)
				if lineData is None:
					continue  // Comentario o línea vacía
				
				processLine(lineData, state)
			
			finalizeBatch(state)
			return state.document
		
		def normalizeLine(line, stack):
			// Retorna: {nivel, texto, esComentario, esMultilínea}
			if line.startswith("#"):
				return None  // Comentario
			
			nivel = countIndentation(line)
			textoSinIndent = line[indentLength:]
			
			if textoSinIndent.startswith(":"):
				esMultilínea = True
			
			return {nivel, textoSinIndent, esMultilínea}
		
		def processLine(lineData, state):
			// Lógica principal del paso 1 al 5 descrito arriba
			
			ultimoNodo = state.stack[-1] if state.stack else None
			
			// PASO 2: Multilínea
			if ultimoNodo.esMultilínea and lineData.nivel >= len(state.stack):
				ultimoNodo.añadirLínea(lineData.texto)
				return
			
			// PASO 3: Validación
			if lineData.nivel > state.currentLevel + 1:
				lanzarError("Salto de nivel")
			
			// PASO 4: Crear nodo
			node = crearNodo(lineData.texto, lineData.nivel)
			
			// PASO 5: Stack
			if lineData.nivel == 0:
				state.document.append(state.currentRoot)
				state.currentRoot = node
				state.stack = [node]
			else:
				while len(state.stack) > lineData.nivel:
					state.stack.pop()
				state.stack[-1].añadirHijo(node)
				state.stack.append(node)
			
			state.currentLevel = lineData.nivel 
		
	subSubheader:Validaciones nodos con namespace
		
	Content:
		Las validaciones ocurren en dos momentos clave durante el parseo:
		
	Content:
		**1. Al crear un nodo nuevo (validación de namespace):**
		
		Cuando se crea un nodo, el parser intenta deducir su namespace a partir de:
		- El namespace explícito en el nodo: `Email(com.example.docs)`
		- El namespace del padre
		- El repositorio de namespaces disponibles
		
		Si no puede deducir un namespace válido, lanza ERROR.
		
	Content:
		**2. Al finalizar un nodo (validación de estructura y contenido):**
		
		Esto ocurre cuando:
		- Aparece un nodo con nivel <= nivel actual (cierre de rama)
		- Se alcanza el final del fichero
		
		En este momento se valida:
		
	code:
		si tipoNodo == NODE:
			validar que número de hijos sea correcto
				ejemplo: Email tiene {From, To, Body, Priority}
				se valida contra el namespace
		
		sino (si es STRING, NUMBER, TEXT, etc):
			validar contenido según tipo
				ejemplo: NUMBER debe cumplir ^(\-|\+)?\d+\.\d+(e(\-|\+)?\d+)?$
		
		si es TEXT (multilínea):
			validar que no tenga hijos (solo contenido textual)
		
		si es BOOLEAN:
			validar que valor sea "true" o "false"
	
	Content:
		**Ejemplo completo de validación:**
		
	code:
		Entrada inválida:
			Email (com.example.docs):
				From: John
				Priority: alto  ← ERROR: "alto" no es booleano
		
		Stack durante procesado:
			LÍNEA "From: John": ok, nivel 1
			LÍNEA "Priority: alto": crear nodo
				- Deducir tipo de Priority en namespace
				- Tipo = BOOLEAN
				- Valor = "alto"
				- Validar con regex BOOLEAN
				- FALLA: "alto" != "true" | "false"
				- Lanzar ParseException
		
	Subheader:	Los nodos del lenguaje
		
	Content:
		En la descripción del lenguaje habíamos dicho que los tipos de datos no tienen limitación
		ni están ligados a un lenguaje, por lo que las validaciones sólo deberían ser comprobadas
		mediante expresiones regulares o métodos que aseguren este hecho.
		
		Tenemos los siguientes tipos de nodos:
		
		* NODE
		* TEXT
		* URL
		* NATURAL
		* INTEGER
		* RATIONAL
		* NUMBER
		* BINARY
		* HEXADECIMAL
		* BASE64
		* BOOLEAN
		 	
		Las expresiones regulares que podríamos usar para validar nodos son:
		 
	Code:
		BINARY       = ^(0|1|\s)+$
		BOOLEAN      = ^0|1$
		HEXADECIMAL  = ^([a-f0-9]|\s)+$
		INTEGER      = ^(\-|\+)?\d+$
		NATURAL      = ^\d+$
		NUMBER       = ^(\-|\+)?\d+\.\d+(e(\-|\+)?\d+)?$
		RATIONAL     = ^(\-|\+)?\d+\/\d+$
		 	
	Subheader:Namespaces
		
	subSubheader:Almacenaje
		
	Content:
		Los namespaces se deben obtener de forma independiente. Una estrategia es tener un repositorio de namespaces
		en disco, e ir a buscarlos siempre allí. 
		
	Subheader:Detalles a tener en cuenta
		
	Content:
		Hay algunos detalles que hay que tener en cuenta en el parseo:
		
		* Case-insensitive: Todos los nodos son considerados CASE-INSENSITIVE, 
		  por lo que hay que hacer las transformaciones adecuadas en el proceso de parseo.
		* Base64: Con el texto BASE64 hay que permitir saltos de línea,
		  y hacer un parseo estándar del contenido así obtenido.
		* Para lectura de líneas hay que tener en cuenta tanto formato UNIX como DOS.
		  Por ello permitiremos tanto el salto de línea, como salto de línea + retorno de carro.
		  Esto lo hacemos para permitir ediciones rápidas de ficheros desde cualquier entorno,
		  aunque lo más adecuado sería siempre usar estándar UNIX (sólo carácter de salto de línea).
		 