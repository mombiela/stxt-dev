Document (dev.stxt.namespace): Document Parsing
	Navigation:
		Previous: Previous (ebnf)
		Next: Next (parsers)
		
	Metadata:
		Title: @STXT@ Parsing
		Description: Parsing files in @STXT@ format (unified view)
		Author: Joan Costa Mombiela
		Last Modif: 2025-11-30
	
	header: @STXT@ Parsing
		
	Subheader: Generic process
		
	SubSubheader: Algorithm overview
		
	Content:
		@STXT@ document parsing can be done in a single pass, line by line.
		The central idea is to maintain a simple state with:
		
		* A structure that tells us which is the last open node at each level.
		* An active multiline node (for example, TEXT or BASE64) if there is one.
		* The namespace repository to validate nodes when creating and closing them.
		
		Conceptually, this is equivalent to using a stack of nodes representing
		the current branch of the tree: the root node is at the base of the stack and the last
		node of the current branch is at the top.
		
	Code:
		ALGORITHM: parseFile(file)
			state = initializeState(file)
			
			while not endOfFile(file):
				physicalLine = readLine(file)
				processLine(state, physicalLine)
			
			closeAndValidatePendingNodes(state)
			
			return state.rootNodeList
		
	Content:
		The cost is linear in the size of the file, and the parser can act
		at the same time as a structure and type validator.
		
	SubSubheader: Internal parser state
		
	Code:
		STRUCTURE: Node
			name        // "Title", "Body Content", ...
			type        // NODE, TEXT, BASE64, INTEGER, ...
			level       // indentation level
			parent      // reference to parent node (or null)
			children    // list of child nodes
			value       // for scalar nodes
			text        // text buffer for multiline nodes
			namespace   // node specification according to repository
		
		STRUCTURE: ParserState
			stackByLevel: map<level -> Node>   // last open node at each level
			multilineNode: Node or null        // active TEXT/BASE64 node, if any
			rootNodeList: list<Node>           // level 0 nodes
			namespaceRepository                // access to namespaces
			currentLineNum: integer
			currentFile: identifier
		
	SubSubheader: Main parsing loop
		
	Code:
		func parseFile(file):
			state = initializeState(file)
			
			while !endOfFile(file):
				physicalLine = readLine(file)   // support LF and CRLF
				state.currentLineNum += 1
				processLine(state, physicalLine)
			
			closeAndValidatePendingNodes(state)
			return state.rootNodeList
		
	SubSubheader: Line processing: steps
		
	Content:
		The processing of each line can be broken down into the following steps:
		
		1. Line normalization and level calculation.
		2. Handling multiline nodes.
		3. Decision: multiline text or new node?
		4. Closing nodes when changing level.
		5. Node creation and initial validation via namespace.
		
	subSubheader: Step 1 – Normalization and level calculation
		
	Code:
		func normalizeLine(state, physicalLine):
			// 1. Remove line terminators and trailing spaces
			line = trimRight(physicalLine)
			
			// 2. Empty line
			if line is empty:
				result = new NormalizationResult()
				if state.multilineNode != null:
					result.isMultilineContinuation = true
					result.isBlankLine = true
				else:
					result.isUseless = true     // ignorable
				return result
			
			// 3. Comments (for example, lines starting with '#')
			if isComment(line):
				result = new NormalizationResult()
				result.isUseless = true
				return result
			
			// 4. Level calculation from indentation (tabs/spaces)
			level = calculateLevel(line)              // defines how tabs/spaces are counted
			textWithoutIndent = removeIndentation(line, level)
			
			// 5. Optional transformations to compact/semicompact form
			compactText = compactIfNecessary(textWithoutIndent)
			
			result = new NormalizationResult()
			result.isUseless = false
			result.isMultilineContinuation = false
			result.level = level
			result.text = compactText
			return result
		
	Content:
		Level calculation must be consistent throughout the document.
		The exact rules (for example, how many spaces equal one level)
		are part of the implementation, but the model is always the same:
		an integer representing the depth of the line.
		
	subSubheader: Step 2 – Handling multiline nodes
		
	Content:
		A multiline node is typically a node of type TEXT or BASE64 (according to namespace).
		The following lines, with a strictly greater level, are considered part of the
		text of this node as long as a new node does not appear at the same or higher level
		in the hierarchy.
		
	Code:
		func handleMultilineIfApplies(state, normResult):
			if state.multilineNode == null:
				return false    // not treated as multiline
			
			node = state.multilineNode
			nodeLevel = node.level
			lineLevel = normResult.level
			
			// Blank line inside multiline
			if normResult.isBlankLine:
				node.text += "\n"
				return true
			
			// Rules:
			// - If the line has a level greater than the multiline node's
			//   and does not appear to be a new node, treat as text.
			if lineLevel > nodeLevel and !hasNewNodeSyntax(normResult.text):
				if node.text is empty:
					node.text = normResult.text
				else:
					node.text += "\n" + normResult.text
				return true
			
			// If we reach here, the line is no longer part of the multiline
			// The effective closing of the node will be done when creating the next node
			return false
		
	subSubheader: Step 3 – Decision text vs new node
		
	Code:
		func processLine(state, physicalLine):
			r = normalizeLine(state, physicalLine)
			
			// Ignored line
			if r.isUseless:
				return
			
			// Try to treat as multiline
			if handleMultilineIfApplies(state, r):
				return
			
			// From here, the line is a candidate for a new node
			level = r.level
			content = r.text
			
			// Additional check: in some cases it can be decided that,
			// even if there is indentation, it is still multiline text.
			// This can be refined with additional rules if the language requires it.
			
			// Close nodes according to the new level
			closeNodesOfGreaterOrEqualLevel(state, level)
			
			// Create the new node
			createNewNode(state, level, content)
		
	subSubheader: Step 4 – Hierarchy management by level
		
	Content:
		When a node with level N appears, all nodes with level greater than or equal to N
		are closed. This closing triggers validations of:
		
		* Structure according to namespace.
		* Data types of the values.
		* Additional language restrictions.
		
	Code:
		func closeNodesOfGreaterOrEqualLevel(state, lineLevel):
			for each level in levelsOrderedDescending(state.stackByLevel):
				if level >= lineLevel:
					node = state.stackByLevel[level]
					closeAndValidateNode(state, node)
					delete state.stackByLevel[level]
					
					if state.multilineNode == node:
						state.multilineNode = null
		
	subSubheader: Step 5 – Node creation and initial validation
		
	Content:
		When creating a node, name and value are separated, its type is determined from
		the namespace, it is connected with its parent, and the level and multiline
		structures are updated.
		
	Code:
		func createNewNode(state, level, lineContent):
			name, rawValue = splitNameAndValue(lineContent)   // using ':'
			normalizedName = normalizeCase(name)              // case-insensitive
			
			// Determine parent
			parent = null
			if level > 0:
				parent = state.stackByLevel[level - 1]
			
			// Resolve namespace and node type
			spec = resolveNamespaceForNode(
						state.namespaceRepository,
						parent,
						normalizedName)
			
			if spec == null:
				throwError("Cannot deduce namespace for node '" + normalizedName + "'")
			
			node = new Node()
			node.name = normalizedName
			node.level = level
			node.parent = parent
			node.type = spec.type
			node.namespace = spec
			
			// Insert into tree
			if parent == null:
				add state.rootNodeList <- node
			else:
				add parent.children <- node
			
			// Initialize content according to type
			if node.type is TEXT or BASE64 or other multilineType:
				node.text = rawValue
				node.value = null
				state.multilineNode = node
			else:
				node.value = rawValue
				state.multilineNode = null
			
			// Register as last node of this level
			state.stackByLevel[level] = node
		
	SubSubheader: Example execution trace
		
	Content:
		Let's consider the following document:
		
	Code:
		Email (com.example.docs):
			From: John
			To: Mary
			Body Content:
				Hello
				World
			Priority: 1
		Phone (com.example.docs):
			Number: 123
		
	Content:
		Summarized trace:
		
	Code:
		LINE 1: "Email (com.example.docs):"
			level = 0
			name = "email"
			node = NODE email
			rootList = [Email]
			stackByLevel[0] = Email
		
		LINE 2: "    From: John"
			level = 1
			parent = stackByLevel[0] = Email
			node = child of Email (type according to namespace)
			stackByLevel[1] = From
		
		LINE 3: "    To: Mary"
			level = 1
			close nodes level >= 1 → From is closed
			parent = Email
			node = child of Email
			stackByLevel[1] = To
		
		LINE 4: "    Body Content:"
			level = 1
			close nodes level >= 1 → To is closed
			parent = Email
			node = Body Content (type TEXT according to namespace)
			multilineNode = Body Content
			stackByLevel[1] = Body Content
		
		LINE 5: "        Hello"
			normalizeLine → level = 2, text = "Hello"
			multilineNode = Body Content, lineLevel > nodeLevel
			→ "Hello" is added to Body Content's text
		
		LINE 6: "        World"
			same as previous
			Body Content.text = "Hello\nWorld"
		
		LINE 7: "    Priority: 1"
			normalizeLine → level = 1
			handleMultilineIfApplies returns false
			close nodes level >= 1 → Body Content is closed
			create Priority node as child of Email
			stackByLevel[1] = Priority
		
		LINE 8: "Phone (com.example.docs):"
			normalizeLine → level = 0
			close nodes level >= 0 → Priority and Email are closed
			Email becomes part of rootNodeList
			create Phone node at level 0
			stackByLevel[0] = Phone
		
		LINE 9: "    Number: 123"
			level = 1
			parent = Phone
			child node "Number"
			stackByLevel[1] = Number
		
	Content:
		At the end of the file, the remaining nodes (Number and Phone) are closed
		and the pending root nodes are added to the document's final list.
		
	SubSubheader: Implementation-oriented pseudocode
		
	Code:
		class ParserState:
			stackByLevel = {}           // level -> Node
			multilineNode = None
			rootNodeList = []
			namespaceRepository = ...
			currentLineNum = 0
			currentFile = None
		
		def parse(content, namespaceRepository):
			state = ParserState()
			state.namespaceRepository = namespaceRepository
			
			for rawLine in content.split('\n'):
				state.currentLineNum += 1
				processLine(state, rawLine)
			
			closeAndValidatePendingNodes(state)
			return state.rootNodeList
		
		def processLine(state, rawLine):
			r = normalizeLine(state, rawLine)
			if r.isUseless:
				return
			
			if handleMultilineIfApplies(state, r):
				return
			
			level = r.level
			content = r.text
			
			closeNodesOfGreaterOrEqualLevel(state, level)
			createNewNode(state, level, content)
		
	SubSubheader: Node validations with namespace
		
	Content:
		Validations are performed at two main moments:
		
		1. When creating a new node.
		2. When finishing a node.
		
	Content:
		1. Validation when creating node (namespace):
		
		When creating a node, the parser consults the namespace repository to:
		
		* Determine if the node name is valid as a child of the current parent.
		* Obtain its type (NODE, TEXT, INTEGER, BASE64, etc.).
		* Apply additional rules (for example, required or order).
		
		If a valid namespace cannot be deduced, it means the node could not
		be created in that position and a parsing error occurs.
		
	Content:
		2. Validation when finishing a node:
		
		A node is considered finished when:
		
		* Another node appears with a level equal to or less than its own.
		* The entire file has been processed and the node remains open.
		
		At that moment, it is validated:
		
	Code:
		func closeAndValidateNode(state, node):
			if node.type == NODE:
				validateNumberAndTypeOfChildrenAccordingToNamespace(node)
			else:
				validateContentAccordingToType(node)
		
	Content:
		For scalar nodes (INTEGER, NUMBER, BOOLEAN, etc.) regular expressions or equivalent methods are used. For TEXT/BASE64 nodes,
		it is validated that the structure (for example, absence of children) and the
		format of the content are correct.
		
	Subheader: Language nodes
		
	Content:
		The basic types of the language are not tied to a specific programming language,
		and are normally validated using regular expressions or equivalent methods.
		
		Among others, we have the following types:
		
		* NODE
		* TEXT
		* URL
		* NATURAL
		* INTEGER
		* RATIONAL
		* NUMBER
		* BINARY
		* HEXADECIMAL
		* BASE64
		* BOOLEAN
		 	
		The regular expressions we could use to validate nodes are:
		 
	Code:
		BINARY       = ^(0|1|\s)+$
		BOOLEAN      = ^0|1$
		HEXADECIMAL  = ^([a-f0-9]|\s)+$
		INTEGER      = ^(\-|\+)?\d+$
		NATURAL      = ^\d+$
		NUMBER       = ^(\-|\+)?\d+\.\d+(e(\-|\+)?\d+)?$
		RATIONAL     = ^(\-|\+)?\d+\/\d+$
		
	Subheader: Namespaces
		
	SubSubheader: Storage
		
	Content:
		Namespaces are obtained independently from document parsing.
		A common strategy is to keep a namespace repository on disk
		or in memory, and consult it each time a new node is created.
		
		This repository defines:
		
		* Which nodes can appear in each context.
		* What type each node has.
		* What cardinality or structure restrictions apply.
		
	Subheader: Details to consider
		
	Content:
		There are some important details in parsing:
		
		* Case-insensitive: All node names are considered case-insensitive,
		  so they are normalized in the parsing process.
		* Base64: In BASE64 nodes, line breaks are allowed and a standard
		  parsing of the resulting content is applied.
		* End-of-line formats: Both UNIX (LF) and DOS (CRLF) formats must be supported.
		  This allows files to be edited from different environments
		  without problems, although the recommended standard is always to use LF.
		
		The fact that parsing is strictly line by line and guided by
		indentation allows for very efficient parsers and enables
		them to be used as @STXT@ document validators at load time.